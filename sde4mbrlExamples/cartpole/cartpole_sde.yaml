# XLA_PYTHON_CLIENT_MEM_FRACTION=0.5 python cartpole_sde.py --fun train_sde --cfg cartpole_sde.yaml --out cartpole_bb

# Training and testing data trajectory
data_dir: learned.pkl
# data_dir: random.pkl

# Specify what ratio of the dataset is being used for test data
ratio_test: 0.1
ratio_seed: 10 # Seed used to randomly draw the test data for reproducibility
remove_test_data: False # Specify if the test data must be removed from the training dataset

# Model parameters
model:
  # x: 0, vx: 1, theta: 2, theta_dot: 3
  n_x: 4
  n_y: 4
  n_u: 1

  residual_forces:
    init_value: 0.01
    hidden_layers: [8, 24]
    activation_fn: 'tanh'
  
  control_nn:
    init_value: 0.01
    hidden_layers: [6, 8]
    activation_fn: 'tanh'

  # A priori knowledge of the noise distribution over the given prior dynamics knowledge
  noise_prior_params: [0.005, 0.05, 0.004, 0.01] # To eddit
  # # Comment line above and uncomment line below for ODE
  # noise_prior_params: [0.,0, 0, 0] # neural ODE case
  side_info: True # Inject euler-lagrange side information if True

  # Is the noise term dependent on the control? Does the density needs to be estimated by merging state and control?
  control_dependent_noise: False # If not specified, False is the default value

  # Scaling factor for normalizing neural network inputs
  # data_state_scaling: True # Scale the inputs accoeding to min and max in the dataset
  nn_out_scaling: True # Scaling the output of the NNs according to the gradient on the trajectories
  # x: 0, vx: 1, sin(theta): 2, cos(theta): 3, theta_dot: 4
  state_scaling: [9, 5, 1, 10] # Learned.pkl maximum
  # state_scaling: [31, 14, 1, 13.0] # Random.pkl maximum

  # Comment this key/values for ODE fitting
  diffusion_density_nn:
    # All inputs are contributing to the noise
    # Inputs that contribute to the noise estimation
    # Inputs to dad term are [xdot, sin(theta), cos(theta), theta_dot]
    indx_noise_in: [1, 2, 3] # If not specified, it is all the inputs

    # The learned noise only operates on this set of outputs
    indx_noise_out: [1, 3] # If not specified, it is all the putputs

    # Density scaler function -> learn heteregeous noise or homogeneous noise with none type
    scaler_nn:
      type: scaler
      init_value: 0.01
    
    density_nn:
      init_value: 0.1
      activation_fn: swish
      hidden_layers: [32, 32]
  
  # Stepsize for integration
  stepsize: 0.02

  # Number of particles when sampling posterior or prior distribution
  # This can be changed at runtime
  num_particles: 1

  # Horizon of integration when sampling posterior or prior
  # This can be changed at runtime
  horizon: 1

sde_loss:

  # Random seed for initializing the neural networks
  seed: 1

  # What stepsize to use when fitting the model to the data
  data_stepsize: 0.02
  stepsize: 0.02
  u_sampling_strategy: first

  # Number of particles when fitting the SDE -> If different to the default model num_particles
  num_particles: 1
  num_particles_test: 5
  # # COmment this line For ODE Fitting. There is no need for eval with more than 1 trajectory
  # num_particles_test: 1

  # This is the horizon of integration when computing the loss
  horizon: 30

  # Randomly subsample the horizon to fit only num_sample2consider if given
  num_sample2consider: 5
  # How the states are scaled in the loss computation (this is used to divide the mean square loss)
  obs_weights: [9, 5, 1, 1.0, 10] # learned maximum
  # obs_weights: [31, 15, 1, 1.0, 13.0] # Random maximum

  # Density loss parameters
  density_loss:
    learn_mucoeff:
      type: dnn
      init_value: 0.01
      activation_fn: tanh
      hidden_layers: [8, 8]
    mu_coeff: 10.0 # STrong convexity parameter
    ball_radius: [0.1, 0.1, 0.4] # THe radius of the ball to sample for enforcing local strong convexity
    ball_nsamples: 20 # Number of points to sample in the ball
  
  # Penalty for the error on the prediction
  pen_data: 1.0

  # Penalty on the gradient of the density loss
  pen_grad_density: 1.0 # 0.01

  # Penalty on the local strong convexity constraints
  pen_density_scvex: 1.0

  # Regularization penalty default value for all parameters
  pen_weights: 1.0e-3

  # Penalty on mu learnt
  pen_mu_type: lin_inv
  pen_mu_coeff: 1000.0
  # Scaling down the dad term importance relative to data
  pen_scvex_mult: 0.01

  #########################################################################
  # Extra constraints parameterization
  #########################################################################
  default_weights: 1.0
  special_parameters_pen: # Dev iation from initial guess in init_params
    scaler: 0
    density: 0

sde_optimizer:
  - name: scale_by_adam
    # params:
    #   b1: 0.999
    #   b2: 0.9999
  # - name: add_decayed_weights
  #   params:
  #     weight_decay: 0.001
  - name: linear_schedule
    scheduler: True
    params:
      init_value: -0.01 # Initial learning rate (Negative value for minimization)
      end_value: -0.001
      transition_steps: 10000 # Basically the maximum number of gradient steps 
  # - name: piecewise_constant_schedule
  #   scheduler: True
  #   params:
  #     init_value: -0.001 # Initial learning rate (Negative value for minimization)
  #     boundaries_and_scales:
  #       4000: 10.0
  #       18000: 0.5
  #       30000: 0.2
  

# Training parameters
sde_training:
  train_batch: 512 # The mini batch size for the training dataset
  test_batch: 512 # The mini batch size for the training dataset
  nepochs: 1000 # The number of epochs (full pass over the training dataset)
  patience: 100 # The number of epochs after which to stop the learningif no improvement in solution
  test_freq: 50 # Number of gradient steps after which to evaluate and display losses
  save_freq: 500 # Number of gradient steps after which to save the current losses+nn
  TestStopingCrit:
    TestErrorData: 1.0 # 0.1
    # TestStdData: -0.1 # Maximime the noise of the learned SDE
  TrainStopingCrit:
    totalLoss: 1.0
