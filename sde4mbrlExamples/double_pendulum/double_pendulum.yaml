# XLA_PYTHON_CLIENT_MEM_FRACTION=0.5 python double_pendulum_model.py --fun train --model_dir double_pendulum.yaml --model_type nesde --data DoPe_MeasLow_TopLeft_3

# Groundthruth model of the mass spring damper
# The groundtruth parameters are only used to generate data
model:

  # State, observation, and control inputs
  n_x: 4
  n_y: 4
  n_u: 1

  # This is not used when learned_nominal is not null
  init_params:
    m1: 1.0
    m2: 1.0
    l1: 1.0
    l2: 1.0
    gravity: 9.8

  # A priori knowledge of the noise distribution over the given prior dynamics knowledge
  # LOw dt so scaling accordingly
  # noise_prior_params: [0.0001, 0.0001, 0.001, 0.001]
  noise_prior_params: [0.0001, 0.0001, 0.005, 0.005]
  
  # The parameter specifies if control is enabled or not on the model
  control: False

  # Is the noise term dependent on the control? Does the density needs to be estimated by merging state and control?
  control_dependent_noise: False # If not specified, False is the default value

  diffusion_density_nn:

    # All inputs are contributing to the noise
    # Inputs that contribute to the noise estimation
    # indx_noise_in: [0,1] # If not specified, it is all the inputs

    # The learned noise only operates on this set of outputs
    # For this example, the first component dynamics are well known and not noisy
    # indx_noise_out: [2,3] # If not specified, it is all the putputs

    # Density scaler function -> learn heteregeous noise or homogeneous noise with none type
    scaler_nn:
      type: scaler
      init_value: 0.01
      # activation_fn: tanh
      # hidden_layers: [4, 4]
    
    density_nn:
      init_value: 0.01
      activation_fn: swish
      hidden_layers: [16, 16]
      aggressiveness: 0.75

  # Residual term enabled?
  residual_forces:
    # type: linear # quadratic, cubic,
    type: dnn
    hidden_layers: [8,32]
    activation_fn: 'tanh'
    init_value: 0.001

  # Define the parameters for the SDE solver
  sde_solver: 'euler_maruyama'

  # Stepsize for integration
  stepsize: 0.001

  # Number of particles when sampling posterior or prior distribution
  # This can be changed at runtime
  num_particles: 1

  # Horizon of integration when sampling posterior or prior
  # This can be changed at runtime
  horizon: 1


# Traing SDE parameters
sde_loss:

  # Random seed for initializing the neural networks
  seed: 1

  # What stepsize to use when fitting the model to the data
  stepsize: 0.001

  # Number of particles when fitting the SDE -> If different to the default model num_particles
  num_particles: 1
  num_particles_test: 40

  # This is the horizon of integration when computing the loss
  # It might get clipped to the horizon of each trajectory in the dataset if it's greater than trajectory length
  # horizon: 500
  horizon: 100

  # Randomly subsample the horizon to fit only num_sample2consider if given
  num_sample2consider: 50

  # Density loss parameters
  density_loss:
    learn_mucoeff: False # Should we learn the local strong convexity parameters?
    mu_coeff: 10.0 # STrong convexity parameter
    ball_radius: 0.05 # THe radius of the ball to sample for enforcing local strong convexity
    ball_nsamples: 10 # Number of points to sample in the ball

  # Penalty for the error on the prediction
  pen_data: 1.0

  # Penalty on the gradient of the density loss
  pen_grad_density: 1.0 # 0.01

  # Penalty on the local strong convexity constraints
  pen_density_scvex: 1.0

  # # Penalty on the strong convexity constant mu
  # pen_mu_coeff: 0.01

  # Regularization penalty default value for all parameters
  pen_weights: 0 #1.0e-6

  #########################################################################
  # Extra constraints parameterization
  #########################################################################

  default_weights: 1.0

  # # When penalizing NN parameters, we want these parameters to deviate minimally from the values below
  # # The name must be a substring of the parameters defined in the model   
  # special_parameters_val:
  #   scaler: 0.0 # With zero, the scaler terms get closer to 1
  #   density: 0.0 # With zero parameters, the density term get closer to 

  # # Non specified parameters are set to
  # default_parameters_val: 0.0

  # # Nominal parameters should be dictionary of pre-learned parameters, if available, froma  previous training
  # special_parameters_pen:
  #   # Fres: 1.0
  #   # scaler: 0.0
  #   density: 1.0

  # # Parameters that are known to be nonnegative
  # noneg_params: []


sde_optimizer:
  - name: scale_by_adam
  - name: linear_schedule
    scheduler: True
    params:
      init_value: -0.01 # Initial learning rate (Negative value for minimization)
      end_value: -0.001
      transition_steps: 2000 # Basically the maximum number of gradient steps 
  # - name: adaptive_grad_clip
  #   params:
  #     clipping: 0.001
  

# Training parameters
sde_training:
  train_batch: 512 # The mini batch size for the training dataset
  test_batch: 512 # The mini batch size for the training dataset
  nepochs: 10000 # The number of epochs (full pass over the training dataset)
  patience: 2000 # The number of epochs after which to stop the learningif no improvement in solution
  test_freq: 50 # Number of gradient steps after which to evaluate and display losses
  save_freq: 100 # Number of gradient steps after which to save the current losses+nn
  # epochs_before_checking_improv: 10
  TestStopingCrit:
    TestErrorData: 1.0 # 0.1
    # TestStdData: -0.1 # Maximime the noise of the learned SDE
  TrainStopingCrit:
    totalLoss: 1.0
