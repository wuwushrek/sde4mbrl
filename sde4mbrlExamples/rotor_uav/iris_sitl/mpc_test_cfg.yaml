# Directory to the learned model parameters
learned_model_params: ~/Documents/sde4mbrl/sde4mbrlExamples/rotor_uav/iris_sitl/my_models/iris_sitl_sde.pkl
# learned_model_params: ~/Documents/sde4mbrl/sde4mbrlExamples/rotor_uav/iris_sitl/my_models/iris_sitl_ode_sde.pkl

# Uncomment below to use System Identification-Based model for control
# use_sysId_model: True


# Constraint on the control inputs
input_constr:
  # pwm_1, pwm_2, pwm_3, pwm_4
  input_id: [0, 1, 2, 3]
  input_bound: [[1.0e-4, 1.], [1.0e-4,1.], [1.0e-4, 1.], [1.0e-4, 1.]]


# Enforce the control inputs bound during learning value function
enforce_ubound: True

# # Constraints on the state of the MPC if present
# state_constr:
#   # It represents the indexes of the constrained state variables
#   state_id: [3, 4, 5, 10, 11, 12]
#   # Penalty term for the slack variables
#   state_penalty: [10.0, 10.0, 20.0, 10.0, 10.0, 10.0] # 0.1
#   # slack scaling and constraints
#   # Set of min max values for the slack id above
#   slack_scaling: [3.0, 3.0, 3.0, 3.0, 3.0, 3.0]
#   state_bound: [[-0.5, 0.5], [-0.5, 0.5], [-0.4, 0.7], [-0.8, 0.8], [-0.8, 0.8], [-0.7, 0.7]] #.inf, -.inf
#   # Enforce bound constraints via proximal ?
#   # Doing so augment the number of variables of the problem by the number of
#   # slack constraints
#   slack_proximal: True
#   constr_pen: 0.1

# Setpoint cost parameters
cost_params:
  uref: [0.71, 0.71, 0.71, 0.71]
  uerr: 0.01 # m1, m2, m3, m4 1.0
  # urate_err: 0.001
  perr: [20., 20., 40.] # x, y, z
  verr: [0.93, 1.94, 1.54] # vx, vy, vz
  qerr: [0.1, 0.1, 4.85] # qx, qy, qz
  werr: [3.0, 3.0, 3.0] # wx, wy, wz
  res_mult: 0.01
  u_slew_coeff: 0.1
  # u_slew_coeff: 0.1 # old * 0.05
  # u_slew_coeff: 0.0001
  # This slew constraints are extracted from the dataset through analyse_control_inputs_changes function in sde_rotor_model.py
  # u_slew_constr: [[-18, 0.07], [-26,0.32], [-29, 0.2], [-10, 0.25]]
  # u_slew_constr_coeff: 10.0

# Default
horizon: 20
num_short_dt: 20
short_step_dt: 0.05
# DANGEROUS: To use a time step different higher than the one used during training
long_step_dt: 0.05
discount: 1.0

# Number of particles when sampling the SDE
num_particles: 1


# ########### Uncomment this to track the desired trajectory fast2_lemn.csv or any other in my_data ##########
# trajectory_path: ~/Documents/sde4mbrl/sde4mbrlExamples/rotor_uav/iris_sitl/my_data/fast2_lemn.csv

# # Cost for tracking the trajectory abobe -> Slightly different for cost of tracking a given setpoint. 
# cost_params:
#   uref: [0.71, 0.71, 0.71, 0.71]
#   uerr: 1 # m1, m2, m3, m4 1.0
#   perr: [100., 100., 200.] # x, y, z
#   verr: [5.0, 5.0, 10.0] # vx, vy, vz
#   qerr: [1, 1, 100] # qx, qy, qz
#   werr: [1.0, 1.0, 1.0] # wx, wy, wz
#   res_mult: 0.01
#   u_slew_coeff: 1.0
#############################################################################################################

# Optimizer parameters
apg_mpc:
  # The intial step size in case no linsearh arguments are provided
  stepsize: 1.

  # The maximum number of gradient updates
  max_iter: 100
  max_no_improvement_iter: 100

  # The adaptive coefficient to scale the momentum. nill values mean
  # that it is not used and rather beta_k = k /(k+3) is used as classical acceleration momentum
  # This value should be between 0 and 1
  moment_scale: null

  # The initial momentum.
  beta_init: 0.25

  # # The stoppng criteria of the algorithm based on gradient norm
  atol: 1.0e-8 # The minimum cost difference or 'zero' cost value
  rtol: 1.0e-6

  linesearch:
    init_stepsize: 0.01
    max_stepsize: 10.0 # The maximum admissible step size
    coef: 0.01 # The agressiveness coefficient. The smaller the larger step size in the optimization
    decrease_factor: 0.7 # The decrease factor when performing the armijo linesearch
    increase_factor: 1.3 # The increase factor at each new gradient descent iteration
    # # The reset strategy at each iteration
    # # "conservative": re-use previous stepsize, producing a non increasing sequence of stepsizes. Slow convergence.
    # # "increase": attempt to re-use previous stepsize multiplied by increase_factor. Cheap and efficient heuristic.
    reset_option: increase # or conservative
    maxls: 4 # Maximum number of iterations during the line search

# Parameters for th eone-step simulator to use in open loop control
one_step_params:
  stepsize: 0.01

# Random initial seed
seed: 10

# Scenario for the simulation 
sim_scen:
  t_init: 0.0
  # ['x', 'y', 'z', 'vx', 'vy', 'vz', 'roll', 'pitch', 'yaw', 'wx', 'wy', 'wz']
  pos_init: [0.,  0.,   1.0,  0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.]
  init_std: [0.01, 0.01,  0.01,  0.01,  0.01,  0.01,  0,  0,  0,  0.01, 0.01, 0.01]
  # init_std: [0.0, 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0, 0.0]
  # Target position when no trajectories are given: x, y, z, yaw
  pos_goal: [0.25, 0.5, 1.4, 0.0]
  # Noise on the goal pos standard deviation from the initial state x, y, z, yaw
  # pos_goal_std: [0.001, 0.001, 0.001, 0.001]
  pos_goal_std: [0.0, 0, 0, 0]
  num_steps: 800 # This should be used for position tracking
  num_steps: 2000 # This should be used for trajectory tracking because of how long are the trajectories