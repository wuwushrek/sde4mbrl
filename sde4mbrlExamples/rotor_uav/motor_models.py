""" Motor inputs to thrust and moment model
"""
import jax.numpy as jnp


""" Mixer matrix for quadrotor in X configuration in NED body frame
    The actual vehicle-dependent coefficient will be learned and this array will be updated below
"""
quad_A_Xconf = jnp.array(
    [
        [-0.707, 0.707, 0.707, -0.707],
        [-0.707, 0.707, -0.707, 0.707],
        [-1.0, -1.0, 1.0, 1.0],
        [1.0, 1.0, 1.0, 1.0]
    ]
)

""" Mixer matrix for hexacopter in X configuration in NED body frame
    The actual vehicle-dependent coefficient will be learned and this array will be updated below
"""
hexa_A_Xconf = jnp.array(
    [
        [-1.0,  1.0,    0.5,    -0.5,   -0.5,   0.5],
        [   0,  0,      -0.866, 0.866,  -0.866, 0.866],
        [1.0,  -1.0,     1.0,    -1.0,    -1.0,   1.0],
        [1.0,  1.0,     1.0,    1.0,     1.0,    1.0]
    ]
)

# [TODO, Franck] Better modelings of the motors might be needed
def motor_model(get_params_fn, u, order=1, use_constant_term=False, assume_sym=True, learn_mixer=False):
    """
    Compute the thrust and moment generated by the motors.
    The thrust and moment are computed in the body frame.
    Args:
        get_params_fn: function to get the LEARNABLED parameters of the motor model
        u: the control input to the motors:  4 motors: [u1, u2, u3, u4] or 6 motors: [u1, u2, u3, u4, u5, u6]
        order: the order of the polynomial motor model
        use_constant_term: if True, the constant term is used in the polynomial model
        assume_sym: if True, The parameters multipliying the x and y components of mixer matrix are assumed to be the same
        learn_mixer: if True, the mixer matrix is fully learned instead of multiplying one of the predefined matrices
    Returns:
        float : the thrust generated by the motors
        array : the moment generated by the motors
    """
    # For each motor, compute the thrust by first extracting all the monomials in polynomial model
    if order == 1:
        uvect = jnp.stack((u, jnp.ones_like(u)), axis=1) if use_constant_term else u.reshape(-1, 1)
    elif order == 2:
        uvect = jnp.stack((u**2, u, jnp.ones_like(u)), axis=1) if use_constant_term else jnp.stack((u**2, u), axis=1)
    elif order == 3:
        uvect = jnp.stack((u**3, u**2, u, jnp.ones_like(u)), axis=1) if use_constant_term else jnp.stack((u**3, u**2, u), axis=1)
    else:
        raise ValueError('Invalid order')
    
    # Obtain the parameters of the polynomial model 
    motParams = jnp.array([get_params_fn('coeffMot{}'.format(i)) for i in range(uvect.shape[-1])])

    # Compute the trust for each motor
    thurstPerMotor = jnp.dot(uvect, motParams)

    # If the mixer is learned, use the learned values
    if learn_mixer:
        mixer = jnp.array([get_params_fn('mix{}'.format(i)) for i in range( 2 * u.shape[0])])
        mixer = mixer.reshape((2, u.shape[0]))
        mixer = jnp.vstack([mixer, jnp.array([[1.0,-1.0,1.0,-1.0,-1.0,1.0],[1.0, 1.0, 1.0, 1.0, 1.0, 1.0]])])
        mixerMz = get_params_fn('CoeffDrag')
        mixer = mixer.at[2, :].multiply(mixerMz)
        thurstAndMoment = mixer @ thurstPerMotor
        return thurstAndMoment[-1], thurstAndMoment[:-1]

    # If we don't learn the mixer, use the predefined mixer matrix and scaled it by the learned coefficients
    # This is such that we keep the structure of the mixer matrix but scaled each row to reflect the geometry of the vehicle
    mixerMx = get_params_fn('Lmx')
    mixerMy = mixerMx if assume_sym else get_params_fn('Lmy')
    mixerMz = get_params_fn('CoeffDrag')

    # Pick the mixer matrix depending on the number of motors
    if thurstPerMotor.shape[0] == 4:
        mixer = quad_A_Xconf
    elif thurstPerMotor.shape[0] == 6:
        mixer = hexa_A_Xconf
    else:
        raise ValueError('Invalid number of motors')
    
    # New mixer matrix
    mixer = mixer.at[0, :].multiply(mixerMx)
    mixer = mixer.at[1, :].multiply(mixerMy)
    mixer = mixer.at[2, :].multiply(mixerMz)

    # Compute the thrust and moment
    thurstAndMoment = mixer @ thurstPerMotor

    # Return the thrust and moment
    return thurstAndMoment[-1], thurstAndMoment[:-1]